package avss

import (
	"context"
	"errors"
	"student_25_adkg/logging"
	"student_25_adkg/pedersencommitment"
	"student_25_adkg/rbc"
	"student_25_adkg/secretsharing"
	"student_25_adkg/typedefs"
	"sync"

	"github.com/rs/zerolog"
	"go.dedis.ch/kyber/v4"
	"go.dedis.ch/kyber/v4/share"
	"go.dedis.ch/kyber/v4/util/random"
	"go.dedis.ch/protobuf"
	"golang.org/x/xerrors"
	"google.golang.org/protobuf/proto"
)

var ErrWrongPhase = errors.New("wrong phase")

type AVSS struct {
	nodeID        int64
	conf          secretsharing.Config
	iface         rbc.AuthenticatedMessageStream
	rbc           rbc.RBC[[]byte]
	logger        zerolog.Logger
	shareChannel  chan struct{}
	myDeal        *Deal
	shares        []*share.PriShare
	commitment    []kyber.Point
	result        kyber.Scalar
	finishChannel chan struct{}
	phase         Phase
	sync.RWMutex
}

type Phase int8

const (
	SHARING Phase = iota
	RECONSTRUCTION
)

// Deal contains the two shares for the node at a given index
// generated by pedersencommitment.PedPolyCommit
type Deal struct {
	sShare *share.PriShare
	rShare *share.PriShare
}

func NewAVSS(conf secretsharing.Config, nodeID int64, stream rbc.AuthenticatedMessageStream,
	rbc rbc.RBC[[]byte]) *AVSS {
	registerPointAndScalarProtobufInterfaces(conf.Group)
	return &AVSS{
		conf:          conf,
		logger:        logging.GetLogger(nodeID),
		shareChannel:  make(chan struct{}),
		nodeID:        nodeID,
		iface:         stream,
		rbc:           rbc,
		shares:        make([]*share.PriShare, 0),
		finishChannel: make(chan struct{}),
		phase:         SHARING,
	}
}

// registerPointAndScalarProtobufInterfaces registers the kyber.Point and kyber.Scalar interfaces
// into protobuf so that they can be encoded and decoded. Needs to be called only once
func registerPointAndScalarProtobufInterfaces(g kyber.Group) {
	protobuf.RegisterInterface(func() interface{} {
		return g.Point()
	})
	protobuf.RegisterInterface(func() interface{} {
		return g.Scalar()
	})
}

// marshalCommitment marshal the given Pedersen commitment to an array
// of bytes. Return an error if marshalling kyber.Point caused an error
func marshalCommitment(commits []kyber.Point) ([]byte, error) {
	encoded := make([]byte, 0)

	for _, point := range commits {
		bs, err := point.MarshalBinary()
		if err != nil {
			return nil, err
		}
		encoded = append(encoded, bs...)
	}
	return encoded, nil
}

// unmarshalCommitment unmarshal a Pedersen commitment encoded with marshalCommitment.
// Uses kyber.Group to generate point. The group should be the same as the one used to generate the commitment.
// Returns an error if unmarshalling kyber.Point caused a problem.
func unmarshalCommitment(bs []byte, g kyber.Group) ([]kyber.Point, error) {
	pointSize := g.Point().MarshalSize()

	//
	shares := make([]kyber.Point, 0)
	start := 0
	for start <= len(bs)-pointSize {
		shareBytes := bs[start : start+pointSize]
		s := g.Point().Null()
		err := s.UnmarshalBinary(shareBytes)
		if err != nil {
			return nil, err
		}
		shares = append(shares, s)

		start = start + pointSize
	}

	return shares, nil
}

func marshalShares(sShare, rShare *share.PriShare) (sBytes, rBytes []byte, err error) {
	sBytes, err = protobuf.Encode(sShare)
	if err != nil {
		return nil, nil, err
	}
	rBytes, err = protobuf.Encode(rShare)
	return sBytes, rBytes, err
}

func unmarshalShares(sBytes, rBytes []byte) (sShare, rShare *share.PriShare, err error) {
	sShare = &share.PriShare{}
	err = protobuf.Decode(sBytes, sShare)
	if err != nil {
		return nil, nil, err
	}
	rShare = &share.PriShare{}
	err = protobuf.Decode(rBytes, rShare)
	return sShare, rShare, err
}

// verifyDeal verifies that it belongs to the given Pedersen commitment. Returns true if
// pedersencommitment.PedPolyVerify returns true, otherwise false.
func verifyDeal(deal *Deal, commitment []kyber.Point, config secretsharing.Config) bool {
	sShare := deal.sShare
	rShare := deal.rShare
	index := int64(deal.sShare.I)
	ok := pedersencommitment.PedPolyVerify(commitment, index, sShare, rShare, config.Group, config.Base0, config.Base1)
	return ok
}

// predicate is used in RBC to determine whether the value (commitment in this case)
// is correct. Refer to https://eprint.iacr.org/2021/777.pdf, algorithm 5. Returns
// true if the commitment can be correctly unmarshalled and passes pedersencommitment.PedPolyVerify
func (a *AVSS) predicate(bs []byte) bool {
	commitment, err := unmarshalCommitment(bs, a.conf.Group)
	if err != nil {
		return false
	}

	// Wait for the SHARE message to be received
	<-a.shareChannel
	return verifyDeal(a.myDeal, commitment, a.conf)
}

// sendShares sends the given set of shares produced by pedersencommitment.PedPolyCommit to all nodes
// as a single broadcast.
func (a *AVSS) sendShares(sShares, rShares []*share.PriShare) error {
	sSharesBytes := make([][]byte, len(sShares))
	rSharesBytes := make([][]byte, len(rShares))
	for i := 0; i < a.conf.NbNodes; i++ {
		sBytes, rBytes, err := marshalShares(sShares[i], rShares[i])
		if err != nil {
			return err
		}
		sSharesBytes[i] = sBytes
		rSharesBytes[i] = rBytes
	}

	shareMessage := createShareMessage(sSharesBytes, rSharesBytes)
	// Broadcast the SHARE message
	return a.broadcastMessage(shareMessage)
}

// Start starts listening for message on its network interface and starts listening for
// RBC instances
func (a *AVSS) Start(ctx context.Context) {
	a.listenToInstances(ctx)
	go func() {
		err := a.rbc.Listen(ctx)
		a.logger.Info().Err(err).Msg("RBC Listen was terminated")
	}()

	go func() {
		err := a.start(ctx)
		a.logger.Info().Err(err).Msg("AVSS was terminated")
	}()
}

// listenToInstances listens for finished instances from RBC. This tells the node when
// the sharing phase finishes
func (a *AVSS) listenToInstances(ctx context.Context) {
	go func() {
		finished := make(map[string]struct{})
		for {
			select {
			case <-ctx.Done():
				return
			case state, ok := <-a.rbc.GetFinishedChannel():

				if ok && state.Finished() {
					if _, ok := finished[string(state.Identifier())]; !ok {
						finished[string(state.Identifier())] = struct{}{}
						a.initiateReconstruction(state)
					}
				}
			}
		}
	}()
}

// initiateReconstruction tries to start the RECONSTRUCTION phase of the AVSS when the SHARING
// phase finishes
func (a *AVSS) initiateReconstruction(state rbc.Instance[[]byte]) {
	if !state.Finished() || !state.Success() {
		return
	}
	a.Lock()
	defer a.Unlock()
	if a.phase == RECONSTRUCTION {
		return
	}
	a.phase = RECONSTRUCTION

	commitment, err := unmarshalCommitment(state.GetValue(), a.conf.Group)
	if err != nil {
		return
	}

	a.commitment = commitment

	if !verifyDeal(a.myDeal, commitment, a.conf) {
		return
	}

	siBytes, riBytes, err := marshalShares(a.myDeal.sShare, a.myDeal.rShare)
	if err != nil {
		return
	}

	reconstructMessage := createReconstructMessage(siBytes, riBytes)
	err = a.broadcastMessage(reconstructMessage)
	if err != nil {
		return
	}
}

// Share starts an AVSS instance by sending a SHARE message to all nodes and starts an RBC instance.
// Returns if any of these actions caused an error. Returns as soon as the SHARE messages is sent
// and the RBC broadcast has been initiated (not finished!).
func (a *AVSS) Share(s kyber.Scalar) error {
	// Randomly sample a polynomial s.t. the origin is at s
	p := share.NewPriPoly(a.conf.Group, a.conf.Threshold, s, random.New())
	commit, sShares, rShares, err := pedersencommitment.PedPolyCommit(p, a.conf.Threshold,
		a.conf.NbNodes, a.conf.Group, a.conf.Base0, a.conf.Base1)
	if err != nil {
		return err
	}

	err = a.sendShares(sShares, rShares)
	if err != nil {
		return err
	}

	err = a.reliablyBroadcastCommitment(commit)
	if err != nil {
		return err
	}
	return nil
}

// reliablyBroadcastCommitment reliably broadcasts the given commitment
func (a *AVSS) reliablyBroadcastCommitment(commitment []kyber.Point) error {
	commitBytes, err := marshalCommitment(commitment)
	if err != nil {
		return err
	}
	_, err = a.rbc.RBroadcast(commitBytes)
	if err != nil {
		return err
	}
	return nil
}

// start listens for packets on the interface and handles them. Returns only when the passed context
// is context.Canceled or context.DeadlineExceeded. Blocks until then
func (a *AVSS) start(ctx context.Context) error {
	for {
		bs, err := a.iface.Receive(ctx)
		if err != nil {
			if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
				return err
			}
			a.logger.Error().Err(err).Msg("error receiving message")
			continue
		}
		msg := &typedefs.Packet{}
		err = proto.Unmarshal(bs, msg)
		if err != nil {
			a.logger.Error().Err(err).Msg("error decoding message")
			continue
		}

		ssMessage, ok := msg.GetMessage().(*typedefs.Packet_SsMessageInst)
		if !ok {
			continue
		}

		err = a.handleMsg(ssMessage.SsMessageInst)
		if err != nil {
			a.logger.Err(err).Msg("Error handling message")
			continue
		}

	}
}

// handleMsg handles a message received from the network. Returns an error if
// handling the messages caused an error.
func (a *AVSS) handleMsg(msg *typedefs.SSMessage) error {
	var err error
	switch msg.GetOp().(type) {
	case *typedefs.SSMessage_ShareInst:
		err = a.receiveShare(msg.GetShareInst())
	case *typedefs.SSMessage_ReconstructInst:
		err = a.receiveReconstruct(msg.GetReconstructInst())
	default:
		err = xerrors.New("unknown instruction received in AVSS")
	}
	return err
}

// receiveShare handles the logic for when a SHARE message is received. Returns an error
// if the received shares can't be unmarshalled into a Deal or ErrWrongPhase if the
// protocol is already in the RECONSTRUCTION phase
func (a *AVSS) receiveShare(shareMsg *typedefs.SSMessage_Share) error {
	a.Lock()
	defer a.Unlock()
	if a.phase != SHARING {
		return ErrWrongPhase
	}
	// Extract the shares destined for this node
	si := shareMsg.GetSi()[a.nodeID-1]
	ri := shareMsg.GetRi()[a.nodeID-1]

	sShare, rShare, err := unmarshalShares(si, ri)
	if err != nil {
		return err
	}

	a.myDeal = &Deal{
		sShare: sShare,
		rShare: rShare,
	}

	// Close the channel to indicate that SHARE message has been received and that myDeal is set
	close(a.shareChannel)
	return nil
}

// receiveReconstruct handles the log for when a RECONSTRUCT message is received. Returns an error
// if the received shares can't be unmarshalled into a Deal or ErrWrongPhase if the
// protocol is still in the SHARING phase
func (a *AVSS) receiveReconstruct(receiveMessage *typedefs.SSMessage_Reconstruct) error {
	a.Lock()
	defer a.Unlock()
	if a.phase != RECONSTRUCTION {
		return ErrWrongPhase
	}

	si := receiveMessage.GetSi()
	ri := receiveMessage.GetRi()

	sShare, rShare, err := unmarshalShares(si, ri)
	if err != nil {
		return err
	}
	deal := &Deal{
		sShare: sShare,
		rShare: rShare,
	}

	// Make sure to wait until the share channel is closed indicating that we have received the initial share message
	<-a.shareChannel
	if a.commitment == nil || !verifyDeal(deal, a.commitment, a.conf) {
		return errors.New("no commitment or could not verify share")
	}

	a.shares = append(a.shares, sShare)
	if len(a.shares) < a.conf.Threshold+1 {
		return nil
	}

	// Enough shares to reconstruct the original value
	if a.result == nil {
		result, err := a.reconstruct()
		if err != nil {
			return err
		}
		a.result = result
		close(a.finishChannel)
	}
	return nil
}

// GetFinishedChannel returns a channel that is closed when the protocol finishes
func (a *AVSS) GetFinishedChannel() <-chan struct{} {
	return a.finishChannel
}

// reconstruct tries to reconstruct the secret polynomial and thus the secret scalar
// originally encoded by the dealer. Returns an error if the secret polynomial could
// not be interpolated.
func (a *AVSS) reconstruct() (kyber.Scalar, error) {
	scalars := make([]kyber.Scalar, len(a.shares))
	for i, s := range a.shares {
		scalars[i] = s.V
	}

	// Linear interpolation to get the polynomial
	poly, err := share.RecoverPriPoly(a.conf.Group, a.shares, a.conf.Threshold, a.conf.NbNodes)
	if err != nil {
		return nil, err
	}
	return poly.Secret(), nil
}

func createShareMessage(si, ri [][]byte) *typedefs.SSMessage {
	shareMessage := &typedefs.SSMessage_Share{
		Si: si,
		Ri: ri,
	}
	message := &typedefs.SSMessage{Op: &typedefs.SSMessage_ShareInst{ShareInst: shareMessage}}
	return message
}

func createReconstructMessage(si, ri []byte) *typedefs.SSMessage {
	reconstructMessage := &typedefs.SSMessage_Reconstruct{
		Si: si,
		Ri: ri,
	}
	message := &typedefs.SSMessage{Op: &typedefs.SSMessage_ReconstructInst{ReconstructInst: reconstructMessage}}
	return message
}

func (a *AVSS) broadcastMessage(message *typedefs.SSMessage) error {
	avssInstruction := &typedefs.Packet_SsMessageInst{SsMessageInst: message}
	instruction := &typedefs.Packet{Message: avssInstruction}
	out, err := proto.Marshal(instruction)
	if err != nil {
		return err
	}

	return a.iface.Broadcast(out)
}
